<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Poison Null Byte - Forging a LIBC Leak" /><meta property="og:locale" content="en" /><meta name="description" content="I’ve been doing a lot of work recently on learning the heap and the techniques leveraged to exploit it through HeapLAB by Max Kamper. Particularly the heap as it pertains to Linux with GLIBC. One such technique is known as the Poison Null Byte." /><meta property="og:description" content="I’ve been doing a lot of work recently on learning the heap and the techniques leveraged to exploit it through HeapLAB by Max Kamper. Particularly the heap as it pertains to Linux with GLIBC. One such technique is known as the Poison Null Byte." /><link rel="canonical" href="https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/" /><meta property="og:url" content="https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/" /><meta property="og:site_name" content="Slimicide" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-25T12:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Poison Null Byte - Forging a LIBC Leak" /><meta name="twitter:site" content="@Slimicide_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-25T12:00:00+00:00","datePublished":"2022-11-25T12:00:00+00:00","description":"I’ve been doing a lot of work recently on learning the heap and the techniques leveraged to exploit it through HeapLAB by Max Kamper. Particularly the heap as it pertains to Linux with GLIBC. One such technique is known as the Poison Null Byte.","headline":"Poison Null Byte - Forging a LIBC Leak","mainEntityOfPage":{"@type":"WebPage","@id":"https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/"},"url":"https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/"}</script><title>Poison Null Byte - Forging a LIBC Leak | Slimicide</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Slimicide"><meta name="application-name" content="Slimicide"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /avatar.PNG " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Slimicide</a></div><div class="site-subtitle font-italic">Learning to break things responsibly. Writeups 'n Stuff.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Slimicide" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Slimicide_" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Poison Null Byte - Forging a LIBC Leak</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Poison Null Byte - Forging a LIBC Leak</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Slimicide_">Slimicide</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1669377600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-11-25 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2672 words"> <em>14 min</em> read</span></div></div></div><div class="post-content"><p>I’ve been doing a lot of work recently on learning the heap and the techniques leveraged to exploit it through <code class="language-plaintext highlighter-rouge">HeapLAB</code> by Max Kamper. Particularly the heap as it pertains to Linux with GLIBC. One such technique is known as the Poison Null Byte.</p><p>The Poison Null Byte is a technique in which a heap overflow of just a single byte allows for the manipulation of heap metadata and ultimately, enables the potential to leak sensitive memory addresses such as that of either GLIBC’s base or a heap address, both of which are subject to ASLR and randomized at run-time; they are different on every execution. Hard-coding values subject to ASLR into exploits will not work, they must be resolved at run-time.</p><p>This is where the leak comes in. By forcing a binary to disclose an address while it’s running, that address can be leveraged in further exploitation such as calculating the address for a <code class="language-plaintext highlighter-rouge">one_gadget</code> for example.</p><p>This is where I had the problem of wanting to write about this technique but also not wanting to use a binary from the <code class="language-plaintext highlighter-rouge">HeapLAB</code> course considering those are paid course materials, I don’t want to be showcasing them for free. In the end, I figured that I would just write my own vulnerable binary and get a little bit more experience working with C.</p><p>This way, if my binary is written poorly, it’s actually a bug AND a feature. Win/Win</p><h1 id="1-note">1-Note</h1><hr /><p>Note: <code class="language-plaintext highlighter-rouge">1-Note</code> is linked to an old version of GLIBC: <code class="language-plaintext highlighter-rouge">libc-2.25.so</code>. The <code class="language-plaintext highlighter-rouge">tcache</code> was introduced in <code class="language-plaintext highlighter-rouge">libc-2.26.so</code> and changes the behavior of core mechanisms behind this bug.</p><p>When writing <code class="language-plaintext highlighter-rouge">1-Note</code>, I wanted to try and make the binary seem benign in its operations. I tried to come up with normal reasons to make it perform the operations I wanted it to perform. Eventually, I canned that idea after realizing there was no real logical justification for making the allocations I wanted to make without massively over-engineering it for the showcase of a single bug.</p><p><code class="language-plaintext highlighter-rouge">1-Note</code> is a binary that does exactly what it says on the box. It holds one note. Here is the menu:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>0) Read note.
1) Change note title.
2) Change note contents.
3) Malloc / Free 0x88.
4) Malloc / Free 0xf8 #1.
5) Malloc / Free 0xf8 #2.
6) Change note author.
7) Delete note contents.
8) Exit 1-Note. (Seriously, not *that* OneNote.)
</pre></table></code></div></div><p>Aside from oddly specific, ominous malloc and free calls, it seems relatively harmless. You can change the note’s title, the note’s author and of course the note’s contents, but there is a problem. The inputs to change these data fields suffer from a single byte overflow:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">title</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">title</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">New title: "</span><span class="p">);</span>
	<span class="n">fgets</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="mh">0x18</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span> <span class="c1">//HERE</span>
	<span class="k">break</span><span class="p">;</span>
</pre></table></code></div></div><p>The final character read in by <code class="language-plaintext highlighter-rouge">fgets()</code> will be the string’s null terminator: <code class="language-plaintext highlighter-rouge">\0</code>. By filling the chunk with <code class="language-plaintext highlighter-rouge">0x18</code> bytes of user data, an additional null byte will be appended, overflow and land in the first byte of the succeeding chunk’s <code class="language-plaintext highlighter-rouge">size_field</code>.</p><p>The <code class="language-plaintext highlighter-rouge">size_field</code> is a crucial part of heap metadata. Its role is to tell malloc how far down this one specific chunk goes. Various flags can be set on it too to give a little bit more context on the current state of the chunk such as if the previous chunk is free with the <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag: <code class="language-plaintext highlighter-rouge">0x01</code>.</p><p>The smallest size a malloc chunk can be is <code class="language-plaintext highlighter-rouge">0x20</code> (32 bytes). <code class="language-plaintext highlighter-rouge">0x8</code> (8 bytes) of it is reserved for the chunk’s size field, the remaining <code class="language-plaintext highlighter-rouge">0x18</code> (24 bytes) is to be filled with user data.</p><p>The bottom of the heap contains what is known as the <code class="language-plaintext highlighter-rouge">top_chunk</code>. The <code class="language-plaintext highlighter-rouge">top_chunk</code>’s job is to provide new chunks with their memory when they’re being allocated. The value of the <code class="language-plaintext highlighter-rouge">top_chunk</code> is the size of memory it’s prepared to allocate whenever it’s needed.</p><p>Here’s what that looks like:</p><p><img data-src="/assets/img/Other/PoisonNull/title_chunk.png" alt="Title" data-proofer-ignore> <em>Title Chunk</em></p><p>Ignore the pink quadword. That belongs to the previous chunk which is not involved. Everything in the green belongs to the newly allocated title chunk after choosing the <code class="language-plaintext highlighter-rouge">1) Change note title.</code> option.</p><p>The title chunk is a <code class="language-plaintext highlighter-rouge">0x20</code> sized chunk and the chunk behind it isn’t free so the <code class="language-plaintext highlighter-rouge">prev_in_use</code> (<code class="language-plaintext highlighter-rouge">0x01</code>) flag is set. This makes its <code class="language-plaintext highlighter-rouge">size_field</code>: <code class="language-plaintext highlighter-rouge">0x21</code></p><p>The succeeding blue quadword is actually the <code class="language-plaintext highlighter-rouge">top_chunk</code>. By overflowing the title chunk, an additional null byte is going to overwrite the first byte of the <code class="language-plaintext highlighter-rouge">top_chunk</code>:</p><p><img data-src="/assets/img/Other/PoisonNull/title_chunk_overflow.png" alt="Overflow" data-proofer-ignore> <em>Poison Null Byte</em></p><p>After filling the title chunk with ‘A’s (<code class="language-plaintext highlighter-rouge">0x41</code>), we see the <code class="language-plaintext highlighter-rouge">top_chunk</code> now holds <code class="language-plaintext highlighter-rouge">0x20700</code> instead of the previous <code class="language-plaintext highlighter-rouge">0x207c1</code>. <code class="language-plaintext highlighter-rouge">0xc1</code> has been overwritten with <code class="language-plaintext highlighter-rouge">0x00</code>. You’ll notice the final quadword of title’s user data has turned the same color as the <code class="language-plaintext highlighter-rouge">top_chunk</code>. This is because in overwriting the first byte of the <code class="language-plaintext highlighter-rouge">top_chunk</code>, we actually cleared its <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag (<code class="language-plaintext highlighter-rouge">0x01</code>). More on this later.</p><p>It’s probably time to address the purpose of the <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag and what it does. Like I said earlier, the <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag indicates whether or not the previous chunk is… in use. Malloc needs this information so it can be efficient in how it manages the heap, specifically, free chunks.</p><p>For example, imagine there are two <code class="language-plaintext highlighter-rouge">0x90</code>-sized chunks:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>Irrelevant_Previous_Chunk - ALLOCATED

Chunk_A - FREE
	size_field: 0x91

Chunk_B - ALLOCATED
	size_field: 0x90
</pre></table></code></div></div><p>In malloc’s eyes, Chunk_A is a free chunk because Chunk_B’s <code class="language-plaintext highlighter-rouge">size_field</code> says so. If Chunk_B is now freed, malloc will read Chunk_B’s <code class="language-plaintext highlighter-rouge">size_field</code>, notice the previous chunk is also free and consolidate them together into one single free chunk with a <code class="language-plaintext highlighter-rouge">size_field</code> of <code class="language-plaintext highlighter-rouge">0x121</code> (<code class="language-plaintext highlighter-rouge">0x90</code> + <code class="language-plaintext highlighter-rouge">0x90</code>).</p><p>Note: If a chunk adjacent to the <code class="language-plaintext highlighter-rouge">top_chunk</code> is freed, it will immediately be dissolved and the size will be added to the <code class="language-plaintext highlighter-rouge">top_chunk</code>.</p><p>How it achieves the consolidation is related to why the final quadword of our title chunk turned the same color as the <code class="language-plaintext highlighter-rouge">top_chunk</code> earlier. When a chunk is freed, two main things happen:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1: 
The prev_in_use flag of the succeeding chunk is cleared to reflect the current free chunk.

2: 
The final quadword of the current chunk's user data gets repurposed as a prev_size field.
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">prev_size</code> field is simply the size from the same chunk’s <code class="language-plaintext highlighter-rouge">size_field</code> copied into the final quadword of user data minus the flags. That way when consolidating, malloc can simply read the <code class="language-plaintext highlighter-rouge">prev_size</code> field of the previous quadword to the current target’s <code class="language-plaintext highlighter-rouge">size_field</code> and know how far back to consolidate.</p><p>That was a lot of prerequisite but it is required to appreciate what happens in this technique. Now, as long as the victim of the overflow has a <code class="language-plaintext highlighter-rouge">size_field</code> of at least <code class="language-plaintext highlighter-rouge">0x110</code>, we can make some modifications to the heap that we shouldn’t be allowed to make. Anything less than a size of <code class="language-plaintext highlighter-rouge">0x100</code> and we wipe out the <code class="language-plaintext highlighter-rouge">size_field</code> altogether, that won’t help.</p><p>The question is, what now? How does wiping the first byte of a <code class="language-plaintext highlighter-rouge">size_field</code> result in the leak of a sensitive address? It has to do with how free chunks are stored and protected. Much like the reasoning behind free chunk consolidation, malloc is all about efficiency. When a chunk is freed, it will be stored in its respective <code class="language-plaintext highlighter-rouge">bin</code>.</p><p>For this binary, it is the <code class="language-plaintext highlighter-rouge">UnsortedBin</code> that concerns us. When a chunk is being newly allocated, it will first search the bins to see if it can reuse a previously freed chunk instead of allocating a brand new one from the <code class="language-plaintext highlighter-rouge">top_chunk</code>. The <code class="language-plaintext highlighter-rouge">UnsortedBin</code> is a doubly linked list that resides in a place called the <code class="language-plaintext highlighter-rouge">main_arena</code>. The <code class="language-plaintext highlighter-rouge">main_arena</code> is located at a fixed offset from the base of LIBC. The linking process is tricky to describe but essentially it involves a:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>FD (forward pointer)
BK (backward pointer)
</pre></table></code></div></div><p>Important to note, when malloc is accessing a chunk, it points <code class="language-plaintext highlighter-rouge">0x10</code> bytes before the user data begins.</p><p>The <code class="language-plaintext highlighter-rouge">FD</code> resides in the first quadword of a free chunk’s userdata. The <code class="language-plaintext highlighter-rouge">BK</code> resides in the second.</p><p>I’ll free a chunk and follow the <code class="language-plaintext highlighter-rouge">UnsortedBin</code> <code class="language-plaintext highlighter-rouge">FD</code> to show how it works:</p><p><img data-src="/assets/img/Other/PoisonNull/main_arena_diagram.png" alt="FD" data-proofer-ignore> <em>UnsortedBin</em></p><p>The important part to take away is the chunk placed behind the <code class="language-plaintext highlighter-rouge">main_arena</code> in the <code class="language-plaintext highlighter-rouge">UnsortedBin</code> will always hold the address of the <code class="language-plaintext highlighter-rouge">main_arena</code> in its <code class="language-plaintext highlighter-rouge">FD</code>. When there is only one chunk in the <code class="language-plaintext highlighter-rouge">UnsortedBin</code>, both the <code class="language-plaintext highlighter-rouge">FD</code> and <code class="language-plaintext highlighter-rouge">BK</code> will point to the <code class="language-plaintext highlighter-rouge">main_arena</code>. The <code class="language-plaintext highlighter-rouge">main_arena</code> is a good target because although the addresses are randomized, the offsets stay consistent. If we can leak the <code class="language-plaintext highlighter-rouge">main_arena</code> address, we can subtract the known offset and get the LIBC base address. There’s just one problem. After the chunk is freed and the <code class="language-plaintext highlighter-rouge">main_arena</code>’s address gets written to the chunk, we can no longer read it due to nulling the pointers to free memory after freeing it within the binary:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">contents</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">free</span><span class="p">(</span><span class="n">contents</span><span class="p">);</span>
		<span class="n">contents</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Your note is already empty.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>If we could read chunks which were freed from within the binary, this technique wouldn’t be leveraged, it would be a simple Use-After-Free bug. This is where the poison null byte comes in.</p><h1 id="the-exploit">The Exploit</h1><hr /><p>The goal is to read a <code class="language-plaintext highlighter-rouge">main_arena</code> address which is written to a chunk by freeing it. The caveat being, you can’t read <em>directly</em> from free chunks. So what can we read from? There is only one menu option for reading memory and it’s option: <code class="language-plaintext highlighter-rouge">0) Read note.</code> Using Pwndbg, it’s easy to see what that would look like.</p><p>By choosing <code class="language-plaintext highlighter-rouge">2) Change note contents.</code> and writing some data to the note, this is what it looks like on the heap.</p><p><img data-src="/assets/img/Other/PoisonNull/note_contents.png" alt="Note Contents" data-proofer-ignore> <em>Note Contents</em></p><p>Choosing <code class="language-plaintext highlighter-rouge">0) Read note.</code> now outputs:</p><p><img data-src="/assets/img/Other/PoisonNull/note_output.png" alt="Note Output" data-proofer-ignore> <em>Note</em></p><p>Ok, great. It will read whatever data is written to it. It will also read the other fields which accept input such as the title and the author, although those aren’t important here:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">title</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Title: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">title</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Title: Untitled</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">contents</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">contents</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Empty Note"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">author</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Author: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">author</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Author: Anonymous</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">break</span><span class="p">;</span>
</pre></table></code></div></div><p>We’re going to begin exploiting this binary by firstly allocating the chunks which the read option is is looking for so it will actually include them in the read.</p><p>Use options:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>1) Change note title.
2) Change note contents.
3) Malloc / Free 0x88.
6) Change note author.
</pre></table></code></div></div><p>Option 4 &amp; 5 have been intentionally ignored for now. There’s some setup to do. As it stands, the <code class="language-plaintext highlighter-rouge">contents</code> chunk is size <code class="language-plaintext highlighter-rouge">0x210</code> with the additional <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag making it <code class="language-plaintext highlighter-rouge">0x211</code>.</p><p>By now choosing option <code class="language-plaintext highlighter-rouge">7) Delete note contents.</code>, this will free the <code class="language-plaintext highlighter-rouge">contents</code> chunk, linking it into the <code class="language-plaintext highlighter-rouge">UnsortedBin</code> and writing the associated <code class="language-plaintext highlighter-rouge">FD</code> and <code class="language-plaintext highlighter-rouge">BK</code> to its first two quadwords of user data.</p><p>Now that the <code class="language-plaintext highlighter-rouge">contents</code> chunk is free, we can use option <code class="language-plaintext highlighter-rouge">1) Change note title.</code> and fill it to trigger the poison null byte overflow. It was freed as a <code class="language-plaintext highlighter-rouge">0x210</code>-sized chunk, now it is a free <code class="language-plaintext highlighter-rouge">0x200</code>-sized chunk as a result of the overflow. This will have its consequences later on, there are <code class="language-plaintext highlighter-rouge">0x10</code> bytes which are now unaccounted for.</p><p>There is one more concept to understand before completing this exploit and that is <code class="language-plaintext highlighter-rouge">remaindering</code>. Remaindering is simply malloc splitting apart a free chunk so it can service a request for an allocation of a size smaller than the chunk being split.</p><p>For example, if there is a free chunk of size <code class="language-plaintext highlighter-rouge">0x200</code> sitting in the <code class="language-plaintext highlighter-rouge">UnsortedBin</code> and a request is made for a new allocation of size <code class="language-plaintext highlighter-rouge">0x110</code>, the <code class="language-plaintext highlighter-rouge">0x200</code>-sized chunk will be split to allocate a <code class="language-plaintext highlighter-rouge">0x110</code>-sized chunk, the remaining <code class="language-plaintext highlighter-rouge">0x90</code> of the chunk is going to remain in the <code class="language-plaintext highlighter-rouge">UnsortedBin</code> so it can be reused in a different request.</p><p>Now that that’s out of the way, it’s time to recognize what we have in front of us. A <code class="language-plaintext highlighter-rouge">0x200</code>-sized chunk is now sitting in the <code class="language-plaintext highlighter-rouge">UnsortedBin</code>, holding a <code class="language-plaintext highlighter-rouge">main_arena</code> address waiting to be remaindered. We cannot read from it because we freed it and nulled the pointer we used to have to it. We’re going to have to do something else.</p><p><img data-src="/assets/img/Other/PoisonNull/free_contents.png" alt="Free Contents" data-proofer-ignore> <em>Free Contents</em></p><p>As luck would have it, options 4 &amp; 5 happen to split that chunk really nicely, <code class="language-plaintext highlighter-rouge">0xf8</code> will allocate a chunk of size <code class="language-plaintext highlighter-rouge">0x100</code> which just so happens to be half of the chunk being split.</p><p>We’ll use option <code class="language-plaintext highlighter-rouge">4) Malloc / Free 0xf8 #1.</code> and see what happens to the heap.</p><p><img data-src="/assets/img/Other/PoisonNull/remaindered_1.png" alt="Remaindered" data-proofer-ignore> <em>Remaindered</em></p><p>It’s at this point that I realize there is an unintended way to read the leak that essentially undermines the whole point of this binary. Turns out I’m really good at writing vulnerable binaries; surprise features are showing up. Pretending there isn’t an alternative path, we’ll carry on as normal.</p><p>By this point, the problem has revealed itself on the heap. <code class="language-plaintext highlighter-rouge">vis</code> no longer displays the full heap on account of the heap being misaligned. Our remaindered chunk is falling short of the next <code class="language-plaintext highlighter-rouge">size_field</code> (chunk generated from Option 3). By pushing that poison null byte earlier and turning a chunk of size <code class="language-plaintext highlighter-rouge">0x210</code> to that of a <code class="language-plaintext highlighter-rouge">0x200</code>, <code class="language-plaintext highlighter-rouge">0x10</code> was lost in the process. That missing <code class="language-plaintext highlighter-rouge">0x10</code> is what is causing the current misalignment. In order to read the full heap now, we’ll have to use <code class="language-plaintext highlighter-rouge">dq mp_.sbrk_base 400</code> to dump 400 quadwords from the default heap. This works fine, it’s just not color-coded.</p><p>Here is what’s going on at the bottom of our remaindered chunk currently sitting in the <code class="language-plaintext highlighter-rouge">UnsortedBin</code>:</p><p><img data-src="/assets/img/Other/PoisonNull/misaligned.png" alt="Misaligned" data-proofer-ignore> <em>Misaligned</em></p><p>That <code class="language-plaintext highlighter-rouge">0x90</code> at the bottom is actually the <code class="language-plaintext highlighter-rouge">0x88</code> chunk’s size field which was allocated after we allocated the original <code class="language-plaintext highlighter-rouge">0x210</code> <code class="language-plaintext highlighter-rouge">contents</code> chunk. When we freed that <code class="language-plaintext highlighter-rouge">contents</code> chunk, it wrote its <code class="language-plaintext highlighter-rouge">prev_size</code> field of <code class="language-plaintext highlighter-rouge">0x210</code> in its final quadword of user data. Now that we’re missing <code class="language-plaintext highlighter-rouge">0x10</code> from pushing the poison null byte, the remaindered chunk’s <code class="language-plaintext highlighter-rouge">prev_size</code> field has landed <code class="language-plaintext highlighter-rouge">0x10</code> bytes short. It should be before the succeeding chunk’s <code class="language-plaintext highlighter-rouge">size_field</code>. This is a pretty big problem for reasons we’ll see after our next allocation.</p><p>Using option <code class="language-plaintext highlighter-rouge">5) Malloc / Free 0xf8 #2.</code>, we allocate the remaindered chunk and dive into the heap to see what effect it had:</p><p><img data-src="/assets/img/Other/PoisonNull/missed_prev_in_use.png" alt="Missed prev_in_use" data-proofer-ignore> <em>Missed prev_in_use</em></p><p>After allocating the previously remaindered chunk, it’s no longer free. As such, malloc has attempted to flip the <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag onto the succeeding chunk’s <code class="language-plaintext highlighter-rouge">size_field</code>. For reasons explained above, this flag misses its target. As far as malloc is aware, according to the <code class="language-plaintext highlighter-rouge">0x90</code> chunk, the previous chunk is still free despite us just having allocated it. This makes it a candidate for heap consolidation should we choose to free adjacent chunks.</p><p>By using option <code class="language-plaintext highlighter-rouge">4) Malloc / Free 0xf8 #1.</code>, we free the chunk formerly occupied by <code class="language-plaintext highlighter-rouge">contents</code>.</p><p>Now, by using option <code class="language-plaintext highlighter-rouge">3) Malloc / Free 0x88.</code>, it frees the <code class="language-plaintext highlighter-rouge">0x90</code> chunk, the <code class="language-plaintext highlighter-rouge">0x90</code> chunk notices from its <code class="language-plaintext highlighter-rouge">size_field</code> that the previous chunk is also free considering the <code class="language-plaintext highlighter-rouge">0x90</code> chunk doesn’t have a <code class="language-plaintext highlighter-rouge">prev_in_use</code> flag. It reads its <code class="language-plaintext highlighter-rouge">prev_size</code> field to see how far back it can consolidate (<code class="language-plaintext highlighter-rouge">0x210</code>). This consolidates everything back up the former <code class="language-plaintext highlighter-rouge">contents</code> chunk, leaving an unallocated chunk of size <code class="language-plaintext highlighter-rouge">0x2a0</code>:</p><p><img data-src="/assets/img/Other/PoisonNull/0x2a0.png" alt="0x2a0" data-proofer-ignore> <em>0x2a0</em></p><p>Like all free chunks linked into the <code class="language-plaintext highlighter-rouge">UnsortedBin</code>, this chunk holds the <code class="language-plaintext highlighter-rouge">main_arena</code> address of the <code class="language-plaintext highlighter-rouge">UnsortedBin</code>. <code class="language-plaintext highlighter-rouge">0x2a0</code> is plenty of room to squeeze in a new <code class="language-plaintext highlighter-rouge">contents</code> chunk.</p><p>By using option <code class="language-plaintext highlighter-rouge">2) Change note contents.</code> and supplying it with no data, we now have a functional <code class="language-plaintext highlighter-rouge">contents</code> pointer.</p><p>By using option <code class="language-plaintext highlighter-rouge">0) Read note.</code>, it leaks the address. This address contains non-ascii characters printed as an ascii string. It will not output correctly but it will output. The address can be decoded in an exploit script.</p><p><img data-src="/assets/img/Other/PoisonNull/leaked.png" alt="leaked" data-proofer-ignore> <em>Leaked</em></p><p>Here is the result of the exploit script. To avoid cluttering up this post, I’ll leave the source code for the binary and the exploit script <a href="https://github.com/Slimicide/1-Note/">here</a> on my GitHub if you’re interested.</p><p><img data-src="/assets/img/Other/PoisonNull/exploit.png" alt="Exploit" data-proofer-ignore> <em>Exploited</em></p><h1>:)</h1></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/research/'>Research</a>, <a href='/categories/exploits/'>Exploits</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/exploit/" class="post-tag no-text-decoration" >exploit</a> <a href="/tags/python/" class="post-tag no-text-decoration" >python</a> <a href="/tags/pwntools/" class="post-tag no-text-decoration" >pwntools</a> <a href="/tags/heap-overflow/" class="post-tag no-text-decoration" >heap-overflow</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Poison Null Byte - Forging a LIBC Leak - Slimicide&amp;url=https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Poison Null Byte - Forging a LIBC Leak - Slimicide&amp;u=https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://slimicide.github.io/posts/Poison-Null-Byte-Forging-A-LIBC-Leak/&amp;text=Poison Null Byte - Forging a LIBC Leak - Slimicide" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/HackTheBox-Templated/">HackTheBox - Templated</a><li><a href="/posts/HackTheBox-Forge/">HackTheBox - Forge</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hackthebox/">hackthebox</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/active-directory/">active_directory</a> <a class="post-tag" href="/tags/exploit/">exploit</a> <a class="post-tag" href="/tags/pwntools/">pwntools</a> <a class="post-tag" href="/tags/smb/">smb</a> <a class="post-tag" href="/tags/bloodhound/">bloodhound</a> <a class="post-tag" href="/tags/buffer-overflow/">buffer-overflow</a> <a class="post-tag" href="/tags/evil-winrm/">evil-winrm</a> <a class="post-tag" href="/tags/ldap/">ldap</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Basic-Buffer-Overflows/"><div class="card-body"> <em class="timeago small" data-ts="1662062400" > 2022-09-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Basic Buffer Overflows</h3><div class="text-muted small"><p> Binary exploitation has always interested me. Anything low-level does. You always hear about ROPs and NOPs, Overflows and Shellcode. It’s definitely a very exciting and rewarding skill to learn. Li...</p></div></div></a></div><div class="card"> <a href="/posts/ROPEmporium-Write4/"><div class="card-body"> <em class="timeago small" data-ts="1665489600" > 2022-10-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>ROPEmporium - Write4</h3><div class="text-muted small"><p> For this second post about Binary Exploitation, I was originally going to do just one step up from the last one, but then I decided the act of pushing arguments onto the stack for use in a function...</p></div></div></a></div><div class="card"> <a href="/posts/HackTheBox-Templated/"><div class="card-body"> <em class="timeago small" data-ts="1652477400" > 2022-05-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>HackTheBox - Templated</h3><div class="text-muted small"><p> SSTI or Server-Side Template Injection is a vulnerability that always really confused me but at the same time, really interested me. Add those together and I went about finding out how it worked. ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ROPEmporium-Write4/" class="btn btn-outline-primary" prompt="Older"><p>ROPEmporium - Write4</p></a> <a href="/posts/CVE-2022-27677/" class="btn btn-outline-primary" prompt="Newer"><p>CVE-2022-27677 - Low-hanging SYSTEM shells</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/Slimicide_">Slimicide</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hackthebox/">hackthebox</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/active-directory/">active_directory</a> <a class="post-tag" href="/tags/exploit/">exploit</a> <a class="post-tag" href="/tags/pwntools/">pwntools</a> <a class="post-tag" href="/tags/smb/">smb</a> <a class="post-tag" href="/tags/bloodhound/">bloodhound</a> <a class="post-tag" href="/tags/buffer-overflow/">buffer-overflow</a> <a class="post-tag" href="/tags/evil-winrm/">evil-winrm</a> <a class="post-tag" href="/tags/ldap/">ldap</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
